name: 'Detect Changes (Configuration-Driven)'
description: 'Enhanced change detection using Nx dependency graph with path-based fallback. Accepts domain configuration as JSON input.'
author: 'Pipecraft'

inputs:
  baseRef:
    description: 'Base reference to compare against'
    required: false
    default: 'main'
  domains-config:
    description: 'YAML string of domain configurations (embedded in pipeline at generation time)'
    required: true
  useNx:
    description: 'Whether to use Nx dependency graph for change detection'
    required: false
    default: 'true'
  node-version:
    description: 'Node.js version to use'
    required: false
    default: '24'

outputs:
  changes:
    description: 'JSON object with domain change results (e.g., {"core": true, "docs": false})'
    value: ${{ steps.output.outputs.changes }}
  affectedDomains:
    description: 'Comma-separated list of domains with changes'
    value: ${{ steps.output.outputs.affectedDomains }}
  nxAvailable:
    description: 'Whether Nx is available in the repository'
    value: ${{ steps.nx-check.outputs.available }}
  affectedProjects:
    description: 'Comma-separated list of affected Nx projects'
    value: ${{ steps.nx-filter.outputs.affectedProjects }}

runs:
  using: 'composite'
  steps:
    - name: Set Base Branch
      id: set-base
      shell: bash
      run: |
        base_branch=${{ inputs.baseRef || 'main' }}
        echo "base_branch=$base_branch" >> $GITHUB_OUTPUT
        echo "base_branch=$base_branch" >> $GITHUB_ENV

    - name: Parse Domain Configuration
      id: parse-domains
      shell: bash
      run: |
        # Parse the domains-config YAML input (embedded in pipeline at generation time)
        echo "${{ inputs.domains-config }}" > /tmp/domains-config.yml
        
        # Extract domain names using yq (or fallback to grep/awk)
        if command -v yq >/dev/null 2>&1; then
          DOMAIN_NAMES=$(yq eval 'keys | join(",")' /tmp/domains-config.yml)
        else
          # Fallback: extract domain names without yq
          DOMAIN_NAMES=$(grep -E '^[[:space:]]*[a-zA-Z0-9_-]+:' /tmp/domains-config.yml | sed 's/[[:space:]]*\(.*\):.*/\1/' | tr '\n' ',' | sed 's/,$//')
        fi
        
        echo "domains=$DOMAIN_NAMES" >> $GITHUB_OUTPUT
        echo "üìã Configured domains: $DOMAIN_NAMES"
        
        # Create filters file for paths-filter action
        echo "filters:" > /tmp/path-filters.yml
        cat /tmp/domains-config.yml >> /tmp/path-filters.yml
        
        cat /tmp/path-filters.yml
        echo ""

    - name: Check for Nx
      id: nx-check
      shell: bash
      run: |
        if [ -f "nx.json" ] || ([ -f "package.json" ] && grep -q '"nx"' package.json); then
          echo "available=true" >> $GITHUB_OUTPUT
          echo "üîç Nx detected in repository"
        else
          echo "available=false" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è  Nx not detected, falling back to path-based detection"
        fi

    - name: Setup Node.js
      if: steps.nx-check.outputs.available == 'true' && inputs.useNx == 'true'
      uses: actions/setup-node@v4
      with:
        node-version: ${{ inputs.node-version }}

    - name: Determine Nx CLI package
      if: steps.nx-check.outputs.available == 'true' && inputs.useNx == 'true'
      id: nx-cli
      shell: bash
      run: |
        NX_SPEC=""
        if [ -f "package.json" ]; then
          NX_SPEC=$(node - <<'NODE'
const fs = require('fs')
try {
  const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8'))
  const spec =
    (pkg.devDependencies && pkg.devDependencies.nx) ||
    (pkg.dependencies && pkg.dependencies.nx) ||
    ''
  if (typeof spec === 'string') {
    const cleaned = spec.trim()
    if (cleaned && !cleaned.startsWith('workspace:') && !cleaned.startsWith('file:')) {
      process.stdout.write(cleaned)
    }
  }
} catch {
  // ignore JSON parse errors and fall back to latest
}
NODE
          )
        fi
        if [ -n "$NX_SPEC" ]; then
          echo "package=nx@$NX_SPEC" >> $GITHUB_OUTPUT
        else
          echo "package=nx@latest" >> $GITHUB_OUTPUT
        fi

    - name: Detect Changes with Nx (if available)
      id: nx-filter
      if: steps.nx-check.outputs.available == 'true' && inputs.useNx == 'true'
      shell: bash
      run: |
        echo "üöÄ Using Nx dependency graph for change detection"

        # Get affected projects using Nx
        if command -v npx >/dev/null 2>&1; then
          NX_PACKAGE="${{ steps.nx-cli.outputs.package || 'nx@latest' }}"
          # Get list of affected projects (newline-separated)
          AFFECTED_PROJECTS_RAW=$(npx --yes --package "$NX_PACKAGE" nx show projects --affected --base=${{ steps.set-base.outputs.base_branch }} 2>/dev/null || echo "")

          # Convert newlines to commas for storage
          AFFECTED_PROJECTS=$(echo "$AFFECTED_PROJECTS_RAW" | tr '\n' ',' | sed 's/,$//')
          echo "affectedProjects=$AFFECTED_PROJECTS" >> $GITHUB_OUTPUT

          if [ -n "$AFFECTED_PROJECTS" ]; then
            echo "üì¶ Affected Nx projects: $AFFECTED_PROJECTS"

            # Parse domains dynamically from config
            IFS=',' read -ra DOMAIN_NAMES <<< "${{ steps.parse-domains.outputs.domains }}"
            
            # Initialize results JSON
            echo "{" > /tmp/nx-results.json
            FIRST=true
            
            # Check each domain dynamically
            for domain in "${DOMAIN_NAMES[@]}"; do
              domain=$(echo "$domain" | xargs) # trim whitespace
              DOMAIN_AFFECTED=false
              
              # Check if any affected project matches this domain name
              IFS=',' read -ra PROJECTS <<< "$AFFECTED_PROJECTS"
              for project in "${PROJECTS[@]}"; do
                project=$(echo "$project" | xargs)
                # Match if project name contains domain name (with flexible - vs _ matching)
                domain_pattern=$(echo "$domain" | sed 's/-/[-_]/g')
                if echo "$project" | grep -qiE "$domain_pattern"; then
                  DOMAIN_AFFECTED=true
                  echo "  ‚úÖ $project matches $domain domain"
                  break
                fi
              done
              
              # Add to JSON
              if [ "$FIRST" = true ]; then
                FIRST=false
              else
                echo "," >> /tmp/nx-results.json
              fi
              echo "  \"$domain\": $DOMAIN_AFFECTED" >> /tmp/nx-results.json
            done
            
            echo "}" >> /tmp/nx-results.json
            
          else
            echo "No affected projects detected"
            # Create empty results
            echo "{}" > /tmp/nx-results.json
            IFS=',' read -ra DOMAIN_NAMES <<< "${{ steps.parse-domains.outputs.domains }}"
            FIRST=true
            for domain in "${DOMAIN_NAMES[@]}"; do
              if [ "$FIRST" = true ]; then
                echo "{" > /tmp/nx-results.json
                FIRST=false
              else
                echo "," >> /tmp/nx-results.json
              fi
              echo "  \"$domain\": false" >> /tmp/nx-results.json
            done
            echo "}" >> /tmp/nx-results.json
          fi
        else
          echo "‚ö†Ô∏è  npx not available, falling back to path-based detection"
          echo "{}" > /tmp/nx-results.json
          echo "affectedProjects=" >> $GITHUB_OUTPUT
        fi
        
        cat /tmp/nx-results.json

    - name: Transform Domain Config for Paths Filter
      id: transform-config
      if: steps.nx-check.outputs.available != 'true' || inputs.useNx != 'true'
      shell: bash
      run: |
        # Transform domains-config from PipeCraft format to paths-filter format
        # PipeCraft format: domain: { paths: [...] }
        # paths-filter format: domain: [...]
        
        # Read the domains config
        cat /tmp/domains-config.yml
        
        # Transform: remove 'paths:' lines and unindent the glob patterns
        sed '/paths:/d' /tmp/domains-config.yml | sed 's/^  -/-/' > /tmp/paths-filter-config.yml
        
        echo ""
        echo "Transformed for paths-filter:"
        cat /tmp/paths-filter-config.yml
        
        # Store as output for use in paths-filter
        {
          echo "filters<<EOF"
          cat /tmp/paths-filter-config.yml
          echo "EOF"
        } >> $GITHUB_OUTPUT

    - name: Detect Changes with Paths Filter (fallback)
      uses: dorny/paths-filter@v3
      id: filter
      if: steps.nx-check.outputs.available != 'true' || inputs.useNx != 'true'
      with:
        base: ${{ steps.set-base.outputs.base_branch }}
        filters: ${{ steps.transform-config.outputs.filters }}

    - name: Generate Outputs
      id: output
      shell: bash
      run: |
        # Determine which detection method was used and build results
        if [ "${{ steps.nx-check.outputs.available }}" == "true" ] && [ "${{ inputs.useNx }}" == "true" ]; then
          # Use Nx results
          CHANGES_JSON=$(cat /tmp/nx-results.json)
          echo "üîç Using Nx dependency analysis results"
          echo "üì¶ Affected projects: ${{ steps.nx-filter.outputs.affectedProjects }}"
        else
          # Use path filter results - convert to JSON
          echo "üìÅ Using path-based change detection"
          echo "{" > /tmp/path-results.json
          
          IFS=',' read -ra DOMAIN_NAMES <<< "${{ steps.parse-domains.outputs.domains }}"
          FIRST=true
          for domain in "${DOMAIN_NAMES[@]}"; do
            domain=$(echo "$domain" | xargs)
            if [ "$FIRST" = true ]; then
              FIRST=false
            else
              echo "," >> /tmp/path-results.json
            fi
            
            # Check if domain appears in filter changes
            if echo "${{ steps.filter.outputs.changes }}" | grep -q "$domain"; then
              echo "  \"$domain\": true" >> /tmp/path-results.json
            else
              echo "  \"$domain\": false" >> /tmp/path-results.json
            fi
          done
          echo "}" >> /tmp/path-results.json
          
          CHANGES_JSON=$(cat /tmp/path-results.json)
        fi
        
        # Output the JSON
        echo "changes<<EOF" >> $GITHUB_OUTPUT
        echo "$CHANGES_JSON" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
        # Build comma-separated list of affected domains without requiring jq
        AFFECTED_DOMAINS=$(CHANGES_JSON="$CHANGES_JSON" node - <<'NODE'
const data = process.env.CHANGES_JSON || '{}'
let parsed = {}
try {
  parsed = JSON.parse(data)
} catch (error) {
  console.warn('‚ö†Ô∏è  Unable to parse change detection JSON:', error.message)
}
const affected = Object.entries(parsed)
  .filter(([, value]) => value === true)
  .map(([key]) => key)
  .join(',')
process.stdout.write(affected)
NODE
)
        echo "affectedDomains=$AFFECTED_DOMAINS" >> $GITHUB_OUTPUT
        
        echo "üìã Change Detection Results:"
        CHANGES_JSON="$CHANGES_JSON" node - <<'NODE'
const data = process.env.CHANGES_JSON || '{}'
try {
  const parsed = JSON.parse(data)
  console.log(JSON.stringify(parsed, null, 2))
} catch (error) {
  console.warn('‚ö†Ô∏è  Unable to pretty-print change detection JSON:', error.message)
  console.log(data)
}
NODE
        echo "üéØ Affected domains: $AFFECTED_DOMAINS"
        echo "  nx-available: ${{ steps.nx-check.outputs.available }}"
